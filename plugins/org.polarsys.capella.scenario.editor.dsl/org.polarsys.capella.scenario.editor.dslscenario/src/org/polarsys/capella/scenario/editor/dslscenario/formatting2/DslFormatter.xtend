/*
 * generated by Xtext 2.18.0.M3
 */
package org.polarsys.capella.scenario.editor.dslscenario.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.polarsys.capella.scenario.editor.dslscenario.dsl.Model
import org.polarsys.capella.scenario.editor.dslscenario.dsl.SequenceMessageType
import org.polarsys.capella.scenario.editor.dslscenario.services.DslGrammarAccess
import org.polarsys.capella.scenario.editor.dslscenario.dsl.Participant
import org.polarsys.capella.scenario.editor.dslscenario.dsl.DslPackage
import org.polarsys.capella.scenario.editor.dslscenario.dsl.SequenceMessage

class DslFormatter extends AbstractFormatter2 {
	
	@Inject extension DslGrammarAccess

	def dispatch void format(Model model, extension IFormattableDocument document) {
		val begin = model.regionFor.feature(DslPackage.Literals.MODEL__BEGIN)
		val end = model.regionFor.feature(DslPackage.Literals.MODEL__END)
		begin.prepend[noSpace]
		begin.append[newLine]
		interior(begin, end)[indent]
		
		model.participants.forEach[ element | element.format ]
		model.messagesOrReferences.forEach[ element | element.format ]
	}

	def dispatch void format(SequenceMessage message, extension IFormattableDocument document) {
		// each sequence messages definition on a separate line
		message.regionFor.feature(DslPackage.Literals.MESSAGE__NAME).append[newLine]
	}

	def dispatch void format(Participant participant, extension IFormattableDocument document) {
		val p = participant.regionFor.feature(DslPackage.Literals.PARTICIPANT__NAME)
		participant.regionFor.feature(DslPackage.Literals.PARTICIPANT__NAME).append[newLine]
	}
	
	
	// TODO: implement for 
}
